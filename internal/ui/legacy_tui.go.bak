package ui

import (
	"fmt"
	"strings"

	bubblekey "github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/bubbles/textarea"
	"github.com/charmbracelet/bubbles/textinput"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"

	"sprayer/internal/apply"
	"sprayer/internal/job"
	"sprayer/internal/llm"
	"sprayer/internal/parse"
	"sprayer/internal/profile"
	"sprayer/internal/scraper"
)

type state int

const (
	stateList state = iota
	stateDetail
	stateFilters
	stateProfiles
	stateScraping
	stateHelp
	stateReview
)

type Model struct {
	jobs          []job.Job
	profiles      []profile.Profile
	activeProfile profile.Profile
	filters       []job.Filter

	state     state
	width     int
	height    int
	err       error
	statusMsg string

	// Components
	list   List
	detail Detail
	review Review

	spinner     spinner.Model
	filterInput textinput.Model

	store        *job.Store
	profileStore *profile.Store
	llmClient    *llm.Client
}

func NewModel() (Model, error) {
	s, err := job.NewStore()
	if err != nil {
		return Model{}, err
	}
	ps, err := profile.NewStore(s.DB)
	if err != nil {
		return Model{}, err
	}

	jobs, _ := s.All()
	profs, _ := ps.All()

	active := profile.Profile{ID: "def", Name: "Default", Keywords: []string{"golang", "rust"}}
	if len(profs) > 0 {
		active = profs[0]
	} else {
		ps.Save(active)
		profs = append(profs, active)
	}

	spin := spinner.New(spinner.WithSpinner(spinner.Dot), spinner.WithStyle(lipgloss.NewStyle().Foreground(colorMauve)))
	fi := textinput.New()
	fi.Placeholder = "Filter keywords..."

	ta := textarea.New()
	ta.Placeholder = "Email body..."

	m := Model{
		store:         s,
		profileStore:  ps,
		jobs:          jobs,
		profiles:      profs,
		activeProfile: active,
		spinner:       spin,
		filterInput:   fi,
		llmClient:     llm.NewClient(),
		state:         stateList,
	}
	m.list = List{Jobs: jobs}
	m.review = Review{Input: ta}
	m.detail = Detail{Viewport: viewport.New(0, 0)}
	m.applyFilters()

	return m, nil
}

func (m Model) Init() tea.Cmd {
	return tea.Batch(m.spinner.Tick, textinput.Blink)
}

func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch {
		case bubblekey.Matches(msg, Keys.Quit):
			return m, tea.Quit
		case bubblekey.Matches(msg, Keys.Help):
			if m.state != stateHelp {
				m.state = stateHelp
			} else {
				m.state = stateList
			}
		case bubblekey.Matches(msg, Keys.Esc):
			if m.state != stateList {
				m.state = stateList
				m.err = nil
			}
		}

		switch m.state {
		case stateList:
			cmds = append(cmds, m.updateList(msg))
		case stateDetail:
			cmds = append(cmds, m.detail.Update(msg))
		case stateFilters:
			cmds = append(cmds, m.updateFilters(msg))
		case stateProfiles:
			cmds = append(cmds, m.updateProfiles(msg))
		case stateReview:
			cmds = append(cmds, m.review.Update(msg))
		}

	case tea.WindowSizeMsg:
		m.width, m.height = msg.Width, msg.Height
		m.list.Width, m.list.Height = msg.Width, msg.Height
		m.detail.Width, m.detail.Height = msg.Width, msg.Height
		m.detail.Viewport.Width, m.detail.Viewport.Height = msg.Width-4, msg.Height-10
		m.review.Width, m.review.Height = msg.Width, msg.Height

	case jobsScrapedMsg:
		m.jobs = msg.jobs
		m.applyFilters()
		m.state = stateList
		m.statusMsg = fmt.Sprintf("Scraped %d jobs", len(msg.jobs))
		go m.store.Save(msg.jobs)

	case errMsg:
		m.err, m.state = msg.error, stateList

	case emailGeneratedMsg:
		m.review.Subject = msg.subject
		m.review.Input.SetValue(msg.body)
		m.review.Input.Focus()
		if len(m.review.Traps) > 0 {
			m.statusMsg = fmt.Sprintf("WARNING: Traps: %v", m.review.Traps)
		} else {
			m.statusMsg = "Draft ready. Ctrl+Enter to send."
		}
	}

	var cmd tea.Cmd
	m.spinner, cmd = m.spinner.Update(msg)
	cmds = append(cmds, cmd)

	return m, tea.Batch(cmds...)
}

func (m *Model) updateList(msg tea.KeyMsg) tea.Cmd {
	switch {
	case bubblekey.Matches(msg, Keys.Enter):
		if len(m.list.Jobs) > 0 {
			m.state = stateDetail
			m.detail.Job = m.list.Jobs[m.list.Cursor]
		}
	case bubblekey.Matches(msg, Keys.Scrape):
		m.state = stateScraping
		return m.startScrape()
	case bubblekey.Matches(msg, Keys.Filter):
		m.state = stateFilters
		m.filterInput.Focus()
	case bubblekey.Matches(msg, Keys.Profiles):
		m.state = stateProfiles
	case bubblekey.Matches(msg, Keys.Sort):
		m.list.Jobs = job.SortBy(job.ByDateDesc)(m.list.Jobs)
		m.statusMsg = "Sorted by Date"
	case bubblekey.Matches(msg, Keys.Send):
		if len(m.list.Jobs) > 0 {
			j := m.list.Jobs[m.list.Cursor]
			m.review.Job = j
			m.review.Traps = parse.CheckForTraps(j.Description)
			m.review.CVPath = m.activeProfile.CVPath
			m.state = stateReview
			m.statusMsg = "Generating draft..."
			return func() tea.Msg {
				s, b, err := apply.GenerateEmail(j, m.activeProfile, m.llmClient, "email_cold")
				if err != nil {
					return errMsg{err}
				}
				return emailGeneratedMsg{s, b}
			}
		}
	default:
		return m.list.Update(msg)
	}
	return nil
}

func (m *Model) updateFilters(msg tea.KeyMsg) tea.Cmd {
	var cmd tea.Cmd
	switch {
	case bubblekey.Matches(msg, Keys.Enter):
		kw := strings.Split(m.filterInput.Value(), ",")
		m.filters = []job.Filter{job.ByKeywords(kw)}
		m.applyFilters()
		m.state = stateList
		m.filterInput.Blur()
	case bubblekey.Matches(msg, Keys.Esc):
		m.filterInput.Blur()
		m.state = stateList
	}
	m.filterInput, cmd = m.filterInput.Update(msg)
	return cmd
}

func (m *Model) updateProfiles(msg tea.KeyMsg) tea.Cmd {
	switch {
	case bubblekey.Matches(msg, Keys.Down), bubblekey.Matches(msg, Keys.Up):
		idx := 0
		for i, p := range m.profiles {
			if p.ID == m.activeProfile.ID {
				idx = i
				break
			}
		}
		idx = (idx + 1) % len(m.profiles)
		m.activeProfile = m.profiles[idx]
	case bubblekey.Matches(msg, Keys.Enter):
		m.state = stateList
	}
	return nil
}

func (m *Model) applyFilters() {
	pipe := job.Pipe(job.Dedup(), job.FlagTraps(), job.SanitizeDescriptions(), job.Pipe(m.filters...), job.SortBy(job.ByScoreDesc))
	m.list.Jobs = pipe(m.jobs)
	m.list.Cursor = 0
}

func (m *Model) startScrape() tea.Cmd {
	return func() tea.Msg {
		s := scraper.All(m.activeProfile.Keywords, "Remote")
		jobs, err := s()
		if err != nil {
			return errMsg{err}
		}
		return jobsScrapedMsg{jobs}
	}
}

type jobsScrapedMsg struct{ jobs []job.Job }
type errMsg struct{ error }
type emailGeneratedMsg struct{ subject, body string }

func (m Model) View() string {
	if m.width == 0 {
		return "loading..."
	}

	var content string
	switch m.state {
	case stateScraping:
		content = fmt.Sprintf("\n\n   %s Scraping...\n\n", m.spinner.View())
	case stateDetail:
		content = m.detail.View()
	case stateFilters:
		content = m.viewFilters()
	case stateProfiles:
		content = m.viewProfiles()
	case stateReview:
		content = m.review.View()
	case stateHelp:
		content = m.viewHelp()
	default:
		content = m.list.View()
	}

	head := styleTitle.Render(fmt.Sprintf("Sprayer • %s (%d)", m.activeProfile.Name, len(m.list.Jobs)))
	footText := "s: scrape • f: filter • p: profiles • enter: view • q: quit"
	if m.err != nil {
		footText = styleError.Render(fmt.Sprintf("Error: %v", m.err))
	} else if m.statusMsg != "" {
		footText = styleSuccess.Render(m.statusMsg)
	}
	foot := styleFooter.Width(m.width).Render(footText)

	return lipgloss.JoinVertical(lipgloss.Left, head, content, foot)
}
